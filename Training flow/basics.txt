
HTML 5
	- Simplified DOCTYPE declaration
		- <!doctype html>
	- Semantic tags
		- div and span 
		- header , nav, footer, article, section, aside
		- figure and figcaption
	- Media elements
		- audio - mp3, ogg, 
		- video - mp4, ogg, 
	- canvas elements
		- draw images and graphics in web pages
	- Form controls
		- Url, search, number, range, date, datetime, color, email
		- form validation attributes - required, min, max
		- Placeholder attribute
		- formmethod, formaction, novalidate
	- Web Storage - localStorage, sessionStorage, WebDatabase
	- Web Sockets
	- Caching feature

CSS 3
	- Cascading Style Sheets
	- Inline, Internal or External
	- Selector
		- tag selector
		- class selector
		- id selector
		- global selector
	- Psuedo classes and elements
		- Psuedo classes define the state of an elements
			- active, disabled, hover, visited etc
		- Psuedo elements are used to specify the position
			- nth-clild, first-child, last-child 
		- selector:<pseudo class/element>
		- a:hover, a:visited, p:first-child
	
	
	- Box model in CSS
		- Div with width and height
		- where the box need to be placed: margin
		- where the content of box need to be aligned : padding
	
JQuery
	- Library vs Framework
	- jQuery is a library of JavaScript functions
	- Functions for formatting, DOM manipulation, AJAX , Form utilities
	- Library is available as production version or developer version
	- Production version is minified file ( jquery.min.js)
	- Developer version is uncompressed file (jquery.js)
	- In production we can also use the CDN Urls.
	- No more document.getElementById() , use selectors
		- Selectors can be Id, class or tag name
	- Use the $() symbol or jQuery() to call jQuery functions
	

Angular 
	- SPA application
	- One index page and multiple child views
	- Child views will be included within the index view based on the route .
	- When ever the route change happens the view gets replaced.
	
Eshop
	- Main Module
		Components - Home, About, Product, Search
		Services - ProductService, AuthService
		Directives 
		Pipes
	- OrderModule
		- Components - Order History, OrderDetails, TrackOrder
		- Services - OrderService
		- Directives
		- Pipes
	- Payment Module
		- Components - Payment View, Refund Status View,
		- Services - PaymentService
		
	- Modules
		- Container for Components, Services, Pipes and Directives
		- Angular Apps are writing in TS, DART, JS
		- TS is a compiled Language from Microsoft
		- It is TypeSafe
		- Dev --> TS --> Compiled --> JS
		- Every component, service, directive, pipe must be part of one module. 
	- Features
		- SPA
		- DI Support
		- Data binding - One way and Two way
		- Forms 
		- Modularity
		- Routing
		- HTML 5 and ES6 specification
		- CLI support - help you to generate components, services, pipes and directive etc using command.
	- Install and run the Angular CLI
		- ng --version
		- npm install -g @angular/cli (visit: https://cli.angular.io)
		- Create angular project 
			ng new <project-name> [--minimal --skip-install]
		- Generate components
			ng generate component <component-name>
			OR
			ng g c <component-name>
			
			eg: ng g c home -> HomeComponent
						(home.component.ts)
						(home.component.html)
						(home.component.css)
						(home.component.spec.ts) <- Test class
				ng g c list-view ->ListViewComponent
						(list-view.component.ts)
						(list-view.component.html)
						(list-view.component.css)
						(list-view.component.spec.ts) 
				
		- Generate Services
			ng generate service <service-name>
			OR
			ng g s <service-name>
			
			eg: ng g s payment -> PaymentService
						(payment.service.ts)
						(payment.service.spec.ts)
		- Generate Directives
			ng g d <directive-name>
			
		- Generate Pipes
			ng g pipe <pipe-name>
			
		- Generate class
			ng g class <class-name>
			
		- Generate modules
			ng g module <module-name>
			
		- Run the application
			ng serve OR ng s
		
		- Build the applications
			ng build
			
		- Run all the tests (Unit testing)
			ng test
			
	- Module decorator
		- @NgModule
			- declarations - Array -> List of components, directives , pipes
			- providers - Array -> List of services (explicitly registered)
			- imports - Array - Imported modules
			- exports - Array - Exported components, pipes, services and directives
			- bootstrap - Array - Bootstraped components
	- Component decorator
		- @Component()
			- selector
			- styles
			- styleUrls
			- template
			- templateUrls
			- providers
	- Directives
		- used to add behaviour to existing elements or add a new element.
		- Threee types of directives
			1) Attribute directive - ngStyle, ngClass, ngModel, ngHide
				<input type="text" [ngModel]="name" />
				<div [ngStyle]="{color:cname}"></div>
			2) Structural directive - used to modify the DOM (add/remove elements)
				eg: *ngIf, *ngFor
				<div *ngIf="age>30">Show me in page</div>
			3) Component directive
				- Has a view file (html) 
				- The component we create is actually a directive
		- It is possible to create custom directives
		
	- Binding 
		- One way binding 
			- interpolation - {{ variable}}
			- Property binding - [propertyName]="value" (input binding)
			- Event binding - (eventName)="eventHandlerFn()" (output binding)
		- Two way binding
			- combine property & event binding - [(attribute)]="handler"
	
	- Pipes
		- Simple TS classes used to format the outputs.
		- Pipes are used in templates to format the text.
		- Built-in pipes 
			- async
			- uppercase, lowercase, titlecase
			- currency, number, percent
			- date
		- Pipes are applied using the | symbol
		- Can use more than one pipes (chaining of pipes)
	- Routing
		- package @angular/router
		- import RouterModule and configure the routes
		- Create a custom router module and configure routes and 
			import the custom module to main module
	- Forms
		- Forms can be created using two methods
			- Template driven forms - FormsModule - @angular/forms
			- Reactive forms - ReactiveFormsModule - @angular/forms			
	- Dependency Injection
		- Angular Services are injectable classes.
		- Inject the service objects into other class constructors (components, pipe, directive, service)
		- Constructor injection
		- Assume we have a service 'DataManager' 
			We want to inject in the HomeComponent  class.
			
			export class HomeComponent{
				constructor(private dm:DataManager)
				{				
				}				
				save(){
					this.dm.getMessage();
				}
			}
			
	- Services
		- Simple typescript classes with reusable functions
		- Services classes need to be decorated with @Injectable()
		- Services can be registered globally or locally ( in module or component)
		- Singleton by default
		
	- Life Cycle Hooks in Angular Component
		- OnInit interface
			- ngOnInit()
		- OnDestroy
			- ngOnDestroy()
		- onChanges
			- ngOnChanges()
			
	- RxJS
		- RxJS is a library for creating asynchronous applications.
		- Promises and Observable are two ways of implementing async operations.
		- Promises are built-in to JavaScript now.
		- But for using Observables we need to use RxJS library.
		- 
		
		products:Product[]=[6];
		doSomething()
		{
			console.log("Started");
			getData()
				.then(successCallback, errorCallback);
			console.log("Finished");
		}
		
		doSomething(){
			console.log("Started");
			getData()
				.subscribe(successCallback, errorCallback);
			console.log("Finished");
		}
		
	- Http Interceptor
		- Interceptor is an Angular Service
		- Whenever an Http Operation is executed the interceptor executes 
		- Acting like a middleware for every HTTP call
		- Pre process the request and Post process the response
		example
		Intercept(req, next){
			const httpsReq = req.clone({
				url: req.url.replace("http://", "https://"),
				setHeaders: { "Authorization": `Bearer ${token}` } 
			});

			return next.handle(httpsReq)
				.pipe(
				  map((event: HttpEvent<any>) => {
					if (event instanceof HttpResponse) {
					  let camelCaseObject = mapKeys(event.body, (v, k) => camelCase(k));
					  const modEvent = event.clone({ body: camelCaseObject });
					  
					  return modEvent;
					}
				  })
				);
		}
		
		- Resolvers
			- Used to resolve the data when routing.
			- executes when a route is activated and before the component is loaded.
			
		- Guard Services
			- CanActivate and CanDeactivate 
			- CanActivateChild and CanLoad
			
		- Unit testing
			- Unit testing - Karma, Jasmine, Mocha, Chai
			- Integration testing - Protractor
			- use 'npm test' or use  'ng test' to run all unit testing cases.
			- describe() - used to create a test suite
				- beforeEach() - executed before each unit test function
				- beforeAll() - executed only before first test funtion. 
				- afterEach() 
				- afterAll()
				- it() - unit test function 
					it('description', testfunction());
					if('should print Hello', ()=>{
						//Test logic goes here
					})
				
-----------------------------------------------------------------------------------
MongoDB
	- Data Storages
		- File based
			- Querying data is difficult. 
			- Plain text files, less security.
			- Difficult to perform CRUD operation
		- Relation databases
			- CRUD operations easy
			- Querying data is faster.
			- use of SQL language
			- Relationships can be implemented. 
			- Normalized data for integrity and consistancy.
			- Better security, backup feature, partitioned storage.
			- Data is structured 
		- NoSQL storage	
			- unstructured , high volume of data
			- better for modern apps like social media, online food order, shopping apps etc
			- All related data stored in single place.
			- primarily JSON is used for storing it. 
			
			{
				id: 123,
				user:{
					name:"Ajay",
					id:12,
					email:"ajay@gmail.com"
				},
				postedDate:"2019-05-20 21:40 PM",
				type:"Image",
				url:"http://testapp.com/abc.jpg",
				comments:[
					{
						id:585, uid:32, text:"Very good", date:'2019-05-20 22:30 PM",replies:[
							{ id:32, uid:546, replytext:"Thanks", replyDate:"2019-05-22 9:40 AM"},
							{ id:32, uid:546, replytext:"Thanks", replyDate:"2019-05-22 9:40 AM"},							
						]
					},
					{
						id:3456, uid:3286, text:"Very good, where are you", date:'2019-05-20 22:30 PM",replies:[
							{ id:32, uid:546, replytext:"Thanks, i am in mumbai", replyDate:"2019-05-22 9:40 AM"},							
						]
					},
					{
						id:3456, uid:3286, text:"Very good, where are you", date:'2019-05-20 22:30 PM",replies:[
							{ id:32, uid:546, replytext:"Thanks, i am in mumbai", replyDate:"2019-05-22 9:40 AM"},							
						]
					}
				],
				likes:[
					{uid:3232, when:'2019-05-43 05:40 PM" },
					{uid:212, when:'2019-05-43 05:40 PM" },
					{uid:3333, when:'2019-05-43 05:40 PM" },
					{uid:54565, when:'2019-05-43 05:40 PM" },
					{uid:556, when:'2019-05-43 05:40 PM" }
				],
				shares:[
					{}
					{}
				]
			}
			
		- NoSQL Data Storage options
			- Document type storage (MongoDB, DocumentDB/CosmosDB SQL API)
			- Key-Value storage - Redis cache, Azure Table API storage
			- Column family storage - Cassandra
			- Graph storage (Neo4j, Gremlin)
			
			
		- MongoDB (Document Storage)
			- Mongodb community and enterprise
			- Current version is 4.x
			- Storing data in BSON ( Binary Json)
			- MongoDB Server and mongoDB client is available
				- Server - mongod.exe
				- Client - mongo.exe (CLI)
			- You can download third party GUI tools - MongoChef, NoSQL Booster , MongoCompass, Mongo3T( Studio3T)
			- VS code provides an extension for CosmosDB which also connects mongoDB
			

.NET Core
-------------------------------------------------
	- Why .NET Core?
		- Modern apps	
			- containerized (Docker)
			- Cross platform support
			- Mobile based apps (apps should be light weight)
			- Apps are cloud based
			- Support for multiple deployment platform 
			- Loosely coupled applications 
				- Microservices based apps
		- Features
			- Open Source
			- Light weight framework
			- Cross platform support
			- Cloud based (cloud oriented)
			- Containerization support
			- Simplified project structure
			- CLI based development
			- Microservices development support
			
		- Project types
			- Console apps
			- Web apps 
				- MVC
				- Web API
				- SPA
			- Class Libraries
			
		- .NET Core (Current 2.2 next release is 3.0)
			- in 3.0, added windows forms
			- ML.NET
		- .NET Core uses nuget packages of .NET Framework
			- .NET Core apps can run on .NET Framework
			- Create Standard class libraries to share the libraries with .NET framework
		
	- .NET Core Project Structure
		- Program.cs -> Main()
			- WebHostBuilder created.
			- Application configurations.
			- host configurations.
			- Logging Configurations
			- DefaultWebHostBuilder().Build().Run()
		- Startup.cs
			- ConfigureServices()
				- Used to configure the Services used in the application
					- Database Server
					- Caching Service
					- MVC Routing 
					- Custom Services.
			- Configure()
				- Used to build the request pipeline.
				- Configuring the middleware
			- Constructor() 
		- appsettings.json
			- Contains the configurations such as ConnectionStrings, AppSettings etc
			- Depends on running env we can choose the appsettings file
				- appsettings.json - Dev
				- appsettings.production.json -Prod
				- appsettings.staging.json - Staging
			- ASPNETCORE_ENVIRONMENT environment variable defines which is the current environment
		- *.csproj
			- List of packages used.
			- Metapackage - Microsoft.AspNetCore.App 
		- Controllers, Models, Views
		- wwwroot folder
			- Static file of the web application
			- js, css, images, text, html 
				
	- Middleware
		- a function that executes when request is coming and response is gone.
		- Use, Map, MapWhen, Run methods can be used.
		- Run()
			- Short circuit method that terminates the request flow and generates the response.
		
	- Configuration Sources
		- Multiple Configuration providers
			- XML file
			- INI file
			- JSON file
			- Environment variable
			- CommandLine args
			- Filekey
			- Azure KeyVault
			- Dictionary (In memory collection)
		- Main -> WebHost.createDefaultBuilder() returns a preconfigured web host.
		- appsettings.json
			- "SqlConnection":"DataSource=localhost;User Id=sa; Password=Password@123"
		- EnvironmentVariable
			- "SqlConnection" :"DataSource=129.54.33.24; UserId=sa;Password=Hexa@123"			
		-CommandLine args
			- "SqlConnection" :"DataSource=129.54.33.55; UserId=sa;Password=Hexa@123"
	
	- Dependency Injection
		- Dependency Injection is not a built in feature of .NET Framework.
			- Need to use third-party DI services (package) such as Ninject, Unity
		- DI is a built in feature of .NET Core.
			- .NET Core uses a built-in DI Service ( IoC container)
			- .NET Core we can replace built-in IoC container with third party containers such as Autofac.
			- Scope, lifetime and number of instance of service objects are managed by IoC container.
			- Easily replace one service implementation with another. 
		
		- Scopes
			- Singleton - Only one instance for the entire application
			- Scoped - One instance per request scope.
			- Transient - Create service instances wherever it is requested. 
		- DI service injection
			- Constructor injection.
			- Method injection
		- Replace with Autofac
	- Logging
		- ILogger<Type>
		- Log providers
			- Console
			- Debug
			- EventSourceLogger
	
	- Publish methods
		- 2 ways 
			- Portable (Framework dependant) 
			- Self Contained 
		- Framework dependant
			- Runtime must be installed in every machine to run the application.
			- When run the 'dotnet publish' by default creates a framework dependant deployment
			- You need a runtime in the running machine. 
			- Publish code size is small. 
			- To execute the published app, we need to use 'dotnet app.dll'.
			
		- Self-contained
			- The publish command published the app along with the runtime.
			- While publishing you need to specify the runtime identifier.
			- eg: dotnet publish -r Win10-x64
			- While publishing it generates a self executable exe file not DLL
			- No 'dotnet' command is required to run it. Just double click or execute in command prompt
			
		- dotnet publish
			- move to bin/Debug/netcoreapp2.2/publish 
			- execute the app using 'dotnet ConsoleApp.dll'
		
		- dotnet publish -r win10-x64 --self-contained
			- move to bin/Debug/netcoreapp2.2/win10-x64/publish 
			- execute by just typing the exe file name 'ConsoleApp.exe'
		
	- MVC
		- Tag Helpers instead of Helper methods
		- View Imports razor file introduced
		- DistributedCache configuration
		- DeveloperException page middleware
		- StatusCode error pages
		- RouteConfig.cs file is removed , mvc routes are configured using Middleware
		
	- Tag Helpers
		- Custom tag helpers
		
	- Cahing
		- Used to improve the performance(reduce response time) of the application
		- Types of caching in .NET Core
			- Response caching - [OutputCache Duration="" VaryByParam=""] in MVC 5
			- cache tag helper
			- In memory Non-distributed cache
			- Distributed Cache
				- InMemory DistributedCache (Not for production, only for Dev and Test)
				- Sql Server DistributedCache (Recommended for Prod) - Relational Database
					- dotnet sql-cache create "connectionstring" schema tablenme
					- dotnet sql-cache create "Data Soruce=XXX" dbo CacheTable
				- Redis DistributedCache  (Recommended for Prod) - NoSQL Database (Key-Value)
				- IDistributedCache Interface
					- InMemoryDistributedCache
					- SqlServerDistributedcache
					- RedisDistributedCache
					
	- Hosting
		- Host is reponsible to start and configure the server.
		- In .NET Core we have 2 types of Host
			- Web Host 
				- Configured with a HTTP request pipeline.
				- Only webhost is able to handle the Http request.
				- Either we can create the instnce of Web Host explicitly using 'new'
				- But, .NET Core provides a WebHost object returned by WebHost.CreateDefaultBuilder()
					- Default WebHost object returned by CreateDefaultBuilder() method is preconfigured.
						- Already configured with Kestral, Logging, Host configuration, Configuration sources etc.
						- But, we can customize the configuration
			- GenericHost
				- Decoupled the Http Pipeline
				- Best suited for creating background apps such as apps monitoring the queues, schedules task
	- State Management
		- Query String - NO
		- Cookies - NO
		- Session - YES
			- You must configure Distributed cache. 
			- Enable the Session service using AddSession()
			- Enable the Session Middleware using UseSession() method
		- Hidden Controls -NO 
		- TempData
			- Can persist the data untill it consumes.
			- It can carry the data even in the redirection scenarios where ViewBag and ViewData cannot be used.
			- In .NET Core TempData is implemented with Providers
				- CookieBasedTempDataProvider (Default)
				- SessionBasedTempDataProvider
		- HttpContext.Items
			- Used to pass the data from Middleware to Action.			
		- Cache - Already Done			
		- DI 
			- Create a Singleton service
			- all controller use the same instance
			- Data is shared using the common instance
		
	- Microservices using .NET Core
		- What is Monolithic application development? - Done
		- What are challenges of using Monolithic apps?
			- Tight coupling
			- Dependency increased
			- Scaling independent modules not possible
			- Less or no technology or language choice
			- Deployment
			- Shared Database
			- Testability
		- Service Oriented Architecture
			- Each module is developed as independent projects (services)
			- They are independently deployable
			- All services will expose well defied endpoints such as HTTP/HTTPS
		- What is Microservices architecture?
			- Create service that are independently developed, deployed and tested.			
		- What are the features of Microservices?
			- Fine grained format of SOA
			- Language and technology agnostic
			- Polyglot persistance
			- Independently scalable services
			- Deployment is faster because deploying services independently
			- Deployment of one service will not cause the downtime of other services.
			- Independently testable
			- Services can communicate each other using well known communication methods
				- Synchronous communication
					- RESTful services
					- .NET remoting (only for .NET microservices)
				- Asynchronous communication
					- Message Queue communication
					- Event based communication				
		- Monolithic vs SOA vs Microservices
		- Case study
			- Event Management Application
				- EventAPI
					- CreateEvents()
					- DeleteEvent()
					- UpdateEvent()
					- RegisterEvent()
					- ViewDetails()
				- IdentityAPI
					- RegisterUser()
					- LoginUser()
					- UpdateProfile()
				- EventUI
					- Angular 7 UI
	- Web API
		- Used to create RESTful services
		- Web API Service Controllers are inherited from ControllerBase 
			- No more RoutePrefix, use Route attribute for controller
				eg: [Route("api/[controller]")] -> api/events
			- [ApiController] attribute which defines the response type of the result
				- conversion of request data to JSON
			- No more route attribute for Actions, Define routes in Http attributes itself
				 eg: [HttpGet("/{id}")]
			- Only JsonFormatter is by default added, Add Xml formatter explicitly
		
		- Action return types can be
			- Specific types 
			- IActionResult
			- ActionResult<T> - new


			
	- EF 
	
	- REST  - HTTP
		- Headers
			- In key-value format
			- Content-Type : application/json
			- Accept : Expected MIME type
			- Aurhorization: "Scheme Value"
				- Bearer JWT Token
				- Basic (U/pwd)
		- HTTP Status Codes
			- 1xx - Informative
			- 2xx - Success (OK -200, Created -201)
			- 3xx - Redirect - (Permenant, Temporary, Cached)
			- 4xx - Client Error (404 -Not Found, 401-unauthorized, 403-Forbidden, 400- BadReqeust)
			- 5xx - Server Error (500- Internal Server Error, 501- Server Timeout)
		- HTTP Methods
			- GET		- Access data from server
			- POST		- Add data to server
			- PUT		- Replace data in server
			- PATCH		- Update the existing
			- DELETE	- Remove item from server
		- URL 
			- Endpoint: Method + URL 
			GET 	/api/products			- Get all products
			POST 	/api/products			- Add a new product
			GET 	/api/products/{id}		- Get item by id
			PUT 	/api/products/{id}		- Update/replace item
			DELETE	/api/products/{id}		- Delete the item
			
		- MIME types
			- major type/minor type
			- Major types
				- text
					- plain (text/plain)
					- xml (text/xml)
					- html (text/html)
					- json (text/json)
					- css (text/css)
					- javascript (text/javascript)
				- audio
					- midi (audio/midi)
					- wav (audio/wav)
					- mp3 (audio/mp3)
				- video
					- avi (video/avi)
					- mp4 (video/mp4)
					- wmv (video/wmv)
				- image
					- png (image/png)
					- jpg (image/jpg)
					- gif (image/gif)
					- bmp (image/bmp)
				- application
					- word doc
					- pdf
					- zip file
					- exe files
					
	- EF
		- Code migrations
			- VS : PowerShell Package Manager Console
			- VS Code: Dotnet CLI commands
					
		- To Add migrations
			- PM  : Add-Migration "InitialCreate"
			- CLI : dotnet ef migrations add "InitialCreate"
			
			this generates a Migrations folder with a migration file. 
			Name: <Timestamp>-InitialCreate.cs
		
		- create the tables
			- PM  : Update-database
			- CLI : dotnet ef database update

	- WebAPI 
		- Documentation tools
			- OpenAPI specification
				- Swashbuckle Swagger - Use this
				- NSwag
		- Client Access
			- Mobile
			- JS Apps (Angular/React/ Ember/VueJs)
			- MVC apps
			- Other Server side apps
			- API can be hosted in a domain such as https://hexaapi.com
			
			- Angular Client app hosted on https://client.app.com
			- the API block all external requests coming from other domains 
			- Cross Origin Request 
			- CORS policies (Cross Origin Resource Sharing)
				- Provide access based on domain
					- Allow access only to *.microsoft.com, *.synergetics-india.com
					- Also provide access to all domain using *
				- Allow access only to certain Http methods
					- Allowed method - GET, PUT , POST
				- Allow certain request headers
		- Custom Formatter
			- Inherit the class from TextOutputFormatter
		- Custom Filter
			- Exception filter
		
		- Authentication
			- Forms Authentication
			- Windows Authentication
			- OAuth authentication
				- Google, Facebook, Twitter, Microsoft
			- JWT authentication
			
	- RabbitMQ
		- Communication types
			- Synchronous 
				- RESTful
			- Asynchronous
				- Messaging Queue service
				- Event driven architecture
		
		- RESTful communication
			- Synchronous type
			- One to one communication
			- Sender and receiver must be online
			- Receiver is always sending a response to sender
			- Sender and reciver is well aware about what is sending and how to process it.
		- Queue messaging
			- Asynchronous
			- One to many is possible
			- No immediate processing of request, request will be stored in queue get processed later
			- No response expected.
			- Sender and receiver can be offline.
			- There is no proxy or gateway issues. 
			
		- Queue messaging
			- AMQP protocol - Advanced Message Queuing Protocol
				- RabbitMQ - Pivotal
				- Service Bus - Azure
				
			- RabbitMQ Architecture
				- Producer - One who send the message
				- Exchange - A component where the messages are sent
				- Queue - Temporary storage of message, Exchange is forwarding message to queue.
				- Consumer - The one who consumes the message from queue
				- Binding - Connection between producer and exchange. A Binding key is used.
				- Subscription - How the queue is connected to exchange
					- Direct
					- Fanout
					- Topic					
				

		
		
Azure Cloud
	- On-Premise servers
		- Infrastructure Cost
		- Backup
		- Scaling 
		- Security
		- mangement cost/activites/ monitoring
		- automation
	- Cloud	
		- No need to invest on infrastructure
		- Automated backup (SLA)
		- Global access 
		- Scaling (Pool of resources)
		- automatic monitoring and management
		- Security
		- Geo-fencing that runs apps within taxation boundary
		- Pay As You Go
		
	- Types of Cloud
		- Private Cloud - 
		- Public Cloud - Azure , AWS, Google
		- Hybrid Cloud - 
	- Public Cloud (Azure)
		- Cloud Service Models
			- IaaS - Infrastructure as a Servcie
				- Cloud vendor provides only the infrastructure - Compute , storage and network
				- Customer has to create the resource such as VM
				- He will get full control over the resource
				- This model is used by IT Pro
			- PaaS - Platform as as Servcie
				- Cloud vendor gives you a preconfigured platform.
				- Developer is getting a connection string or url to use the app or data.
				- User have less control over the infrastructure
			- SaaS - Software as a Servcie
				- App and data is also provided by cloud vendor
				- user have not control over the app and data
				- Eg: Office 365, Dynamics, Skype, facebook, gmail, onedrive, dropbox
			
	- Azure 
		- Subscription
			- Free
				- Free trails - 1 month (Rs 13300/ $200)
				- Sponsorships
				- MCT subscriptions
			- Paid 
				- Pay As You Go
				- Enterprise Agreement
		- Resource Manager
			- ASM - (old ) - Azure Service Management
			- ARM - (new) - Azure Resource Manager
				- https://portal.azure.com
				- Resource Group
					- A logical grouping of resources
					- A container for related services
					- Create, delete and update resources as a group.
					- Group wise billing
					- Set permission in group level
					- Resource Manager Template Deployment (ARM Template) - JSON file
		- How to interact with Azure? (How to create/manage resources in Azure?)
			- Using the Portal (Web UI)
			- Command Line 
				- Azure PowerShell
				- Azure CLI 
			- Azure SDK - C#, Java, Python, JS 
			- ARM template (JSON file)
			- RESTful API
		
		- Storage Account
			- Storage servcie.
			- Used to store unstructured blobs, messages, key-value data storages.
			- Storage account provides 4 services 
				- Blob
					- Unstructured blob files such as video, audio, images, text files and other files
					- Files are stored inside a container (just like a folder)
					- You can set permission for the container
						- Private (Allow access only with proper credentials such as token or key)
						- Container level - Anonymous access allowed for blobs, directory browsing also allowed
						- Blob level - Anonymous access allowed.
					- https://<storageaccountname>.blob.core.windows.net/<containername>/<blobname>
				- Queue
					- Basic queue for application integration.
					- One app can send message another app can receive message.
					- Message is in text format with max of 64kb size.
					- Max TTL for message is 7 days
				- Table
					- Store data in key-value format.
					- Its a nosql storage.
					- Every document/item stored is called an entity.
					- Every entity will have a partition key, row key and a timestamp. 
					- User can add additional attributes.
					- maximum 256 attributes allowed.
				- FileShare
					- Is also used for storing unstructured blob storage.
					- Uses SMB 3.0 protocol
					- This can be mapped as a network drive.
			- Storage Keys
				- Provides a primary key and secodnary key ( Key1 and Key2)
				- Can connect to storage account using the name and key
			- SAS token
				- Provide granular permissions
				- 
			- Blobs
				- Block Blob (Image, Audio, Video etc) (Written as 4 MB blocks)
				- Page Blob (ISO file, VM Disk) (100MB)
				- Append Blob- Block blob with Append feature
		
		- CosmosDB
			- Planet-scale, multi-model database for real-time, mission critical applications.
				- Replicate anywhere in the world, any number copies.
				- CosmosDB offers TableAPI, MongoAPI, SQL APi (DocumentDB), Cassandra, Graph API
					- CosmosDB with SQL Api (DocumentDB) - Document
					- CosmosDB with MongoAPI - Document
					- CosmosDB with Cassandra - Column family
					- ComsmosDB with Table API - Key-value pair
					- CosmosDB with Graph API (Gremlin) - Graph
				- Application modernization
			- SLA
				- High Availability (99.99%)
				- Latency (99.99%)
				- throughput (99.99%)
				- consistency (99.99%)
			- RU (Request Unit)
				- One read of 1 kb data is considered as 1 RU.
				- Capacity planner helps you to calculate the RU reqired and the COST/month
				- Factors affect costing
					- region
					- Thoughput allocated (ru)
					- no of read/writes
					- storage size
					- document size
				- Thoughput can be allocated to Database or individual collections.
					- EshopDB (1000 RU) - shared throughput
						- orders 
						- payments
						- stocks
						- items (1500) - dedicated throughput
				
			- Turn key global distribution
			- Consistency levels
				- Eventual			- Least consitent
				- Consitent Prefix
				- Session			- Default consitent
				- Bounded Staleness
				- Strong			- Strongest consistent
				
			- Mongodb - mongoexport/mongodump and mongoimport
			- Emulator
				- Provides only one cosmosdb account
				- Supports all APIs such as SQL, Mongodb, Cassandra, Table API, Gremlin
				- But provides the client UI only SQL api.
				- No georeplication
				- No consistency levels
				- VNET support not available
	- Azure AppService
		- App Service is a compute service.
		- App Service provides platform for deploying Web Apps, API Apps, and Mobile Apps.
			- PaaS service with buit in support for PHP, Java, .NET, Nodejs 
			- https://<appname>.azurewebsites.net (URL)  = > Map to a custom domain (https://helloapp.in)
		- App Service Plan
			- Where to deploy the apps? (Location)
			- Pricing tier 
				- Free (No SLA, Used for Dev/test, no custom domain mapping, max 10 free apps, Shared Infra)
				- Shared (No SLA, Shared Infra, Used for Dev/Test, support custom domain mapping, charged)
				- Basic (SLA of 99.95%, Dedicated CPU, Charged, not reccommended for production, No deployment slots )
				- Standard (Recommened for Production, 5 Deployment slots, 10 times backup in a day)
					- S1(1 CPU 1.75 GB RAM) , S2 (2 CPU 3.5 GB RAM), S3 (4 CPU 7 GB RAM) - A Series
				- Premium (Costly than Standard, 20 deployment slots, 50 times backup in a day)
					- P1(1 CPU 1.75 GB RAM) , P2 (2 CPU 3.5 GB RAM), P3 (4 CPU 7 GB RAM) - A Series
					- P1V2(1 CPU 1.75 GB RAM) , P2V2 (2 CPU 3.5 GB RAM), P3V2 (4 CPU 7 GB RAM) - D Series
				- Isolated (ASE)
		
			- Deployment
				- Web Deploy
				- FTP
				- Public Repos- CI/CD (Github)
			- Deployment Slots
				- Helps you to redeploy the modified version of app without downtime.
				- Helps you to deploy the application for UAT without affecting the production.
				- Rollback of the new version of app if not satisfied.
		
			- Scaling
				- Scale Up - Vertical Scaling (Increase the instance size)
				- Scale out - Horizontal Scaling ( Create more instances )
					- When more than one instance is created the App Service adds a LB to distribute the workload.
					- Manual scaling 
					- Automatic scaling
						- Scales based on a condition
						- Condition can be set based on a metric
						- Metric can be appservice metric or external resource metric
		
	- API Management Gateway
		- Policies 
			- Product level 
			- API level
			- Operations level
			
		- Version and Revisions
	
	- serverless applications
		- Logic Apps
		- Azure Functions
		- Azure Contianer Instances (ACI)
				
	- Logic Apps
		- Integration Platform as a Service (IPaaS)
		- Define workflow
		- While defining the workflow we can integrate multiple SaaS apps
		= Connectors
			- Triggers 
				- Polling trigger
				- Pushing trigger
				- Reccurance trigger
			- Actions
		- How to create a workflow?
			- Simple demo
		- Integration Account
			- Biztalk application
				- Orachestrating workflow
				- JSON to XML
				- XML to Json
				- EDIFACT to JSON
			- Biztalk is used for B2C and B2B integration.
			- stores the schema, maps , agreements, licences, partners etc which is used for b2b or b2c integration in Logic app. 
	- Azure Function App
		- It is also a serverless computing service.
		- Logic app is for workflow creation and function is for atomic operations (modular)
		- Logic app provides visual designer but function app need to be coded.
		- You can use C# or JS to write functions.
		- Function can be developed using Portal, VS Code or Visual Studio.
		- For local development using VS Code or VS you can use 'azure function tools' package.
		- In portal you can write C# scripts (csx), or js files.
		- If you are developing locally you can publish to Function App.
		- A function App is a collection of multiple functions.
		- Two version of Function App available (function app runtime)
			Version 1.0  (.NET Framework)
			Version 2.0 (.NET Core)
		- Pricing models
			- Consumption plan
				- Function max duration is 5 minutes by default. Update to max 10 minutes. 
			- App Service plan
				- Use an existing app service plan.
				- No time limit 
		- Bindings
			- Bindings allow your function to connect to different azure services.
			- There are 3 types of bindings in function.
				- Input binding
					- Trigger binding. - Storage queue, it is a type of input binding
				- Output bindings
		- Timer Trigger 
			- CRON expression ( * * * * * )
				
Docker
	- Deployment of apps
		- need to make changes in the systen 
			- Install framework, set environment vars, fs changes etc
			- reinstall or upgrade existing installations
		- Version conflits/compatability issues with other apps
			- resolve conflits and compatability issues by creating VMs
		
	- VM (Hardware Virtualization) disadvantages
		- Need to allocate CPU, RAM, HDD from Host machine
		- Less number of VMs can be created in a host 
		- Takes more time to create the vm
		- More time required to up and ready the application, not suitable for scaling
		- Resource utilization is not optimal
	- Containerization
		- Package the application and runtime in a logical container
		- No dependencies need to be installed in Host machine.
		- Containers uses the CPU and RAM from host machine.
		- Host machine requires a container engine to run the containers
			- Container engines can be Docker, LXD, LXC, RKT
	- Docker 
		- Docker supports multiple platforms whereas others support only linux.
		- You can develop containerized apps in Windows, Mac and Linux.
		- Docker supports 2 types of containers 
			- Linux containers 
			- Windows containers
		- Linux container
			- The Guest OS will be Linux
			- Linux containers can run only on Linux Host
		- Windows container
			- The Guest OS will be windows (nanoserver, servercore)
			- Windows containers are not supported in Linux Host
		- If you install Docker Desktop for Windows you can develop and test Linux and Windows containers.
		- To install docker on windows - enable the following features 
			- Hyper-V
			- Containers 
	- Docker concepts
		- Images
		- Containers
		- fs Layers
		- registries
		- Docker-compose
		- YAML configuration
		- Dockerfile
		
		
	- Eshop image ( image id, image name, a set of layers)
		- Eshop container 1	( container id, container name, network config)
		- Eshop container 2
		
	- Storage location of image is called registry or repository
		- Local repository - In local machine storage
		- Cloud repository - Publicly accessible internet location
			- Pvt repository - ACR, GCR, ECR
			- Public repository - DockerHub
	- Dockerfile
		- Is a docker image config file that contains the instructions to build an image.
		Commands for Docker file
			
			FROM <base image name>
			WORKDIR <dir path in image>
			COPY <local file path/pattern> <image folder>
			LABEL author sonusathyadas
			LABEL creationDate 2019-09-12
			RUN <cmd args>
				- Specify the commands that needs to run at the time of building the image.
			CMD <cmd args>
				- Specify the commands that needs to run at the time of running  the image.
			EXPOSE <port number>
			ENTRYPOINT <cmd args>
				- Specify the commands that needs to run at the time of running  the image but typically this is used to run commands that start the application.
				
		- run the following command to build the image
			docker build -t <imagename> <path of dockerfile>
			Tag name: is the image name. in the format of <imagename:version>
			sampleapp:v1
			mymvcapp:1.0
			mydemoapp  - default tag 'latest' is used here
			
			eg: docker build -t sampleapp:latest .
		
		- Run the docker image as a container
			docker run --name="containername" -p 5000:80 -d -it --rm <imagename>
			
			docker run -p 5000:80 sampleapp:latest
		-Tag the images
			docker tag <source image> <alias name>
			
			docker tag sampleapp:latest sonusathyadas/sampleapp:latest
			
			Tagging does not creates a new image. 
			
	- .dockerignore file
		- Ignore files and folders that you need to ignore from copying to the docker image.
	- Multi-stage build process
		- docker build -t insuranceportal .
		
		
	- Run containers on Azure
		- Web App for Containers - App Service
		- Azure Container Instances - Serverless
		- Azure Kubernetes Servcie (AKS) - Clustered Service
		- Azure Service Fabric (SF) - Clustered servcie
			
	- ACI
		- Serverless computing
		- A single container is running in one ACI
		- Queick and easy 
			
	- Docker compose
		- Multi container deployment.
		- Use a YAML config file to specify the list of services you want to deploy.
		- Run the 'docker-compose up' command to run all services in one go.

AKS
----
	Azure Kubernetes Service
	Kubernetes
		- K8S is an orchestrator for manging the containers in a cluster.
		- It takes care of creation, deletion, upgrades and scaling of containers inside a cluster.
		- AKS is an Azure Service that provides preconfigured Kubernets in a cluster.
			- Amazon - EKS - Elastic Kubernets Service
			- Google - GKS - Google Kubernetes Service (GCS)
		
		- Docker Swarm, DC/OS , Kubernetes
		- Components of Kuberntes cluster
			- Worker nodes (Nodes which deploys the containers)		
				- Kubernetes agent is installed in workers (kublet)
			- Master node (K8S orchestrator is installed )
				- Inside the master the apiServer service allows users to connect to master 
			
		- AKS is a preconfigured cluster
			- Managed master.
			- User need not to create the master. Azure will automatically create and manage it.
			- the ACS service is charging for master also.
				
Event Grid
	- Communication methods
		- Sync - REST Api
		- Asynchronous
			- Message
			- Event based 
				- One to may 
				- Asynchronous
				- Real time
		- Custom topics
		
Azure DevOps
	- Stake holders of project dev
		- Top managers
		- Project managers
		- Team leads
		- Developers
		- Designers
		- Database engineers
		- Testers
		- Deployment engineers
	
	- Azure DevOps componetns
		- Boards - Top managers / project managers
		- Repos - Dev team 
		- Tests - Testers
		- Pipelines - Deployment engineers
		- Artefacts - Project manger
	
	- Pipelines
		- Build pipeline
		- Release pipeline
	
Service Fabric
	- What is Azure Service Fabric?
		- SF is a cloud platofrm for deploying microservices. (Its a cluster for Microservices)
		- SF is an SDK for developing Microservices. (Programming model).
	- Developing SF applications.
		- K8S cluster can deploy only Containerized apps.
		- K8S cluster can deploy monolithic as well as microservice apps in containerized format.
		
		- SF cluster is used for deploying only microservices developed using SF SDK.
		- It can deploy code based apps and containerized apps. 
		
	- Service Fabric app types
		- Reliable Actor
			- Actor patterns
			- Jobs or Task in background.
		- Reliable Statefull Services
			- Store the user state and app state in worker node.
		- Reliable Stateless Services
			- Web app - MVC/WebAPI
		- Containers
			- Deploy existing docker containers.
			- No need to make code changes.
		- Guest-executable
			- Is used to deploy java, nodejs, php , python apps
	- Emulator
		- SF Local cluster
			- 1 Node 
			- 5 Node cluster.
			

	
	
	
	
	
	
	
	
	